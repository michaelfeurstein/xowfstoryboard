set :debug 1
set :autoname 1
set :policy ::xowfstoryboard::experiment-policy

#
# Define a Property for the workflow to configure it.  When we create
# the workflow, we can pass e.g.
#
#   storyboard.wf?m=create-new&...&p.wf-notation=natural-language&...
#
# to the workflow. This parameter is kept as an instance variable of
# the workflow instance.
#
Property wf_notation -default "natural-language" -allow_query_parameter true
Property time_elapsed -default 0
Property htmlPreview -default "Enter a storyboard to begin..."

Action initialize -proc activate {obj} {
  set wf_notation [$obj property wf_notation]
  ns_log notice "storyboard.wf --> wf_notation:${wf_notation}"

  set name [$obj name]
  if {[$obj is_new_entry $name]} {
    #$obj title "Fresh '${wf_notation}' storyboard ($name)"
    $obj title "Storyboard Language Experiment"
  }
}

Action start \
	-next_state editing \
	-label {Start} \
	-title {Start}

Action save \
	-label {save storyboard draft} \
	-title {Save Draft}

save proc next_state {} {
	ns_log notice "experiment.wf --> Action:save next_state:editing"
	set wf_notation [[:object] get_property -name wf_notation]
	set result [::xowfstoryboard::check_storyboard [[:object] get_property -name editor] $wf_notation]
	set sb_status [dict get $result storyboard_status]
	[:object] set_property -new 1 htmlPreview [dict get $result html]
	set htmlResult [[:object] get_property -name htmlPreview]
	if {$sb_status} {
		util_user_message -message "Storyboard OK"
	} else {
		util_user_message -message "Storyboard ERROR"
	}

	# How does this work
	#[::xowfstoryboard::StoryboardHandler hello]

	return editing
}

Action finish \
	-next_state finished \
	-label {finish} \
	-title {Finished} \
	-proc activate {obj} {
		::xowfstoryboard::time_elapsed $obj
}

finish proc next_state {} {
	ns_log notice "experiment.wf --> Action:finish next_state:finished"
	ns_log notice "\n----------------\n[:serialize]\n\n-------------\n object:[[:object] get_property -name editor]"
	return finished
}

State initial -actions {start} -form en:experiment_landing.form -form_constraints {
	{experiment_id:text,size=40,help_text=Enter your experiment ID,style=width:15%}
}

State editing -actions {save finish} -form en:storyboard.form -view_method edit -form_constraints {
   #editor:monaco_storyboard,required,validator=storyboard
   editor:monaco_storyboard
}

State finished -form en:experiment_summary.form -view_method view -form_constraints {
   experiment_id:text,disabled=true
   time_elapsed:text,disabled=true
}

:object-specific {
	#:mixin add ::xowfstoryboard::StoryboardMixin
	#:mixin add ::xowfstoryboard::StoryboardHandler
	::xo::cc set_parameter template_file view-experiment

	# this breaks my styling more than it helps
	#::xo::cc set_parameter MenuBar 0

	# this seems hacky but does the job of only hiding the MenuBar
	template::set_css_property -class navbar -property display -value none
	#template::set_css_property -class folders -property display -value none
}

#:object-specific {
#	set ctx [:wf_context]
#
#	[$ctx wf_definition_object submit_to_supervisor] proc next_state {} {
#	#check if all coauthors have confirmed this submission
#	#set confirmed [:property mv_agreement]
#	#foreach [tlf_ephorus::unlist_coauthors -name 0 [:self]]
#	if {[llength [[:object] get_property -name mv_agreement]] ne [llength [tlf_ephorus::unlist_coauthors -name 0 [:object]]]} {
#		return "confirm"
#	} else {
#		return "submitted"
#	}
#}
